const express = require('express');
const { Pool } = require('pg');
const cors = require('cors');
const path = require('path');
const { exec } = require('child_process');
const http = require('http'); // Giữ lại http cho redirect
const https = require('https'); // Thêm module https
const fs = require('fs'); // Thêm module fs để đọc file cert
const { WebSocketServer } = require('ws');
const pty = require('node-pty');
const url = require('url');

const app = express();
// Cổng 3001/3000 không còn là cổng chính, 443 sẽ là cổng chính
// const port = process.env.PORT || 3001; 

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

app.use(cors());
app.use(express.json({ limit: '10mb' }));

// SỬA LỖI: Bổ sung lại hàm sendWsMessage bị thiếu
const executionClients = new Map(); // Map drillId -> Set of ws clients
function sendWsMessage(drillId, message) {
    const clients = executionClients.get(drillId);
    if (clients) {
        clients.forEach(client => {
            // Check if readyState exists and is OPEN before sending
            if (client.readyState === 1) { // WebSocket.OPEN = 1
                try {
                    client.send(JSON.stringify(message));
                } catch (err) {
                    console.error(`[Execution ${drillId}]: Error sending WebSocket message:`, err);
                    // clients.delete(client);
                }
            }
        });
    }
}

// --- START: Thêm logic cho Test Run (Chạy thử) ---
const activeTestRuns = new Map(); // Map scenarioId -> { status: 'running' }
const testRunClients = new Map(); // Map scenarioId -> Set of ws clients

// Helper để gửi log Test Run qua WebSocket
function sendTestRunWsMessage(scenarioId, message) {
    const clients = testRunClients.get(scenarioId);
    if (clients) {
        // Định nghĩa biểu thức chính quy để loại bỏ mã ANSI
        // Regex này sẽ tìm và loại bỏ các chuỗi điều khiển màu sắc và định dạng
        const ansiRegex = new RegExp(
            '[\\u001B\\u009B][[\\]()#;?]?[0-9]{1,4}(?:;[0-9]{0,4})*(?:;[0-9]{0,4})*[m,K,H,f,J,s,u,A,B,C,D,G]',
            'g'
        );

        // Loại bỏ mã ANSI khỏi tin nhắn trước khi gửi
        // Đảm bảo 'message' là string trước khi .replace()
        const cleanedMessage = String(message).replace(ansiRegex, '');

        clients.forEach(client => {
            if (client.readyState === 1) { // WebSocket.OPEN
                try {
                    // Gửi tin nhắn đã được làm sạch
                    client.send(JSON.stringify({ type: 'log', data: cleanedMessage }));
                } catch (err) {
                    console.error(`[Test Run ${scenarioId}]: Error sending WebSocket message:`, err);
                }
            }
        });
    }
}
// --- END: Thêm logic cho Test Run ---


// --- API ĐỌC DỮ LIỆU ---
// ... (Toàn bộ code API của anh/chị từ dòng 41 đến 1144) ...
// app.get('/api/data', ...)
// ...
// app.post('/api/admin/seed-demo-data', ...)
// (GIỮ NGUYÊN TOÀN BỘ PHẦN API)
// ... (Toàn bộ code API của anh/chị từ dòng 41 đến 1144) ...

app.get('/api/data', async (req, res) => {
    try {
        const usersQuery = 'SELECT id, username, role, first_name, last_name, description, first_name || \' \' || last_name AS fullname FROM users';
        const drillsQuery = 'SELECT * FROM drills ORDER BY start_date DESC';

        const scenariosQuery = `
            SELECT
                s.id, s.name, s.role, s.basis, s.status, s.created_by, s.created_at, s.last_updated_at, s.attachment, s.application_name, s.type,
                COALESCE(
                    (SELECT json_agg(steps.* ORDER BY steps.step_order) FROM steps WHERE steps.scenario_id = s.id),
                    '[]'::json
                ) as steps
            FROM scenarios s
        `;

        const stepDepsQuery = 'SELECT * FROM step_dependencies';
        const drillScenariosQuery = 'SELECT * FROM drill_scenarios';
        const drillScenarioDepsQuery = 'SELECT * FROM drill_scenario_dependencies';
        const drillStepAssignmentsQuery = 'SELECT * FROM drill_step_assignments';
        const drillCheckpointsQuery = 'SELECT * FROM drill_checkpoints';
        const drillCheckpointCriteriaQuery = 'SELECT * FROM drill_checkpoint_criteria';
        const executionStepsQuery = 'SELECT * FROM execution_steps';
        const executionScenariosQuery = 'SELECT * FROM execution_scenarios';
        const drillGroupDepsQuery = 'SELECT * FROM drill_group_dependencies';
        const applicationsQuery = 'SELECT * FROM applications ORDER BY app_name ASC';

        const results = await Promise.all([
            pool.query(usersQuery),
            pool.query(drillsQuery),
            pool.query(scenariosQuery),
            pool.query(stepDepsQuery),
            pool.query(drillScenariosQuery),
            pool.query(drillScenarioDepsQuery),
            pool.query(drillStepAssignmentsQuery),
            pool.query(drillCheckpointsQuery),
            pool.query(drillCheckpointCriteriaQuery),
            pool.query(executionStepsQuery),
            pool.query(executionScenariosQuery),
            pool.query(drillGroupDepsQuery),
            pool.query(applicationsQuery)
        ]);

        const [
            usersRes,
            drillsRes,
            scenariosRes,
            stepDepsRes,
            drillScenariosRes,
            drillScenarioDepsRes,
            drillStepAssignmentsRes,
            drillCheckpointsRes,
            drillCheckpointCriteriaRes,
            executionStepsRes,
            executionScenariosRes,
            drillGroupDepsRes,
            applicationsRes
        ] = results.map(r => r.rows);

        const scenarios = {};
        const steps = {};
        scenariosRes.forEach(scen => {
            const stepIds = [];
            if (scen.steps && scen.steps.length > 0) {
                scen.steps.forEach(step => {
                    const dependsOn = stepDepsRes
                        .filter(dep => dep.step_id === step.id)
                        .map(dep => dep.depends_on_step_id);
                    steps[step.id] = { ...step, dependsOn };
                    stepIds.push(step.id);
                });
            }
            scenarios[scen.id] = { ...scen, application: scen.application_name, steps: stepIds };
        });

        const checkpointsByDrill = {};
        drillCheckpointsRes.forEach(cp => {
            if (!checkpointsByDrill[cp.drill_id]) {
                checkpointsByDrill[cp.drill_id] = {};
            }
            const criteria = drillCheckpointCriteriaRes.filter(crit => crit.checkpoint_id === cp.id);
            checkpointsByDrill[cp.drill_id][cp.id] = { ...cp, criteria };
        });

        const drills = drillsRes.map(drill => {
            const scenariosInDrill = drillScenariosRes
                .filter(ds => ds.drill_id === drill.id)
                .sort((a, b) => a.scenario_order - b.scenario_order)
                .map(ds => {
                    const dependsOn = drillScenarioDepsRes
                        .filter(dep => dep.drill_id === drill.id && dep.scenario_id === ds.scenario_id)
                        .map(dep => dep.depends_on_scenario_id);
                    return { id: ds.scenario_id, dependsOn, group: ds.group_name };
                });

            const step_assignments = drillStepAssignmentsRes
                .filter(a => a.drill_id === drill.id)
                .reduce((acc, a) => {
                    acc[a.step_id] = a.assignee_id;
                    return acc;
                }, {});

            const group_dependencies = drillGroupDepsRes
                .filter(dgd => dgd.drill_id === drill.id)
                .reduce((acc, curr) => {
                    let group = acc.find(g => g.group === curr.group_name);
                    if (!group) {
                        group = { group: curr.group_name, dependsOn: [] };
                        acc.push(group);
                    }
                    group.dependsOn.push(curr.depends_on_group_name);
                    return acc;
                }, []);

            return {
                ...drill,
                scenarios: scenariosInDrill,
                step_assignments,
                checkpoints: checkpointsByDrill[drill.id] || {},
                group_dependencies
            };
        });

        const executionData = {};
        // Gom execution data cho steps, scenarios, và criteria
        executionStepsRes.forEach(exec => {
             if (!executionData[exec.drill_id]) executionData[exec.drill_id] = {};
             if (exec.step_id) executionData[exec.drill_id][exec.step_id] = exec;
        });
        executionScenariosRes.forEach(exec => {
             if (!executionData[exec.drill_id]) executionData[exec.drill_id] = {};
             if (exec.scenario_id) executionData[exec.drill_id][exec.scenario_id] = exec;
        });
         // Lấy data criteria trực tiếp từ bảng execution_checkpoint_criteria thay vì join phức tạp
        const executionCriteriaRes = await pool.query('SELECT * FROM execution_checkpoint_criteria');
        executionCriteriaRes.rows.forEach(exec => {
             if (!executionData[exec.drill_id]) executionData[exec.drill_id] = {};
             if (exec.criterion_id) executionData[exec.drill_id][exec.criterion_id] = exec;
        })


        res.json({ users: usersRes, drills, scenarios, steps, executionData, applications: applicationsRes });

    } catch (err) {
        console.error('Error fetching initial data:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// OPTIMIZED: Endpoint to get just the list of in-progress drills
app.get('/api/public/drills', async (req, res) => {
    try {
        const drillsQuery = `
            SELECT d.id, d.name, d.description, d.execution_status
            FROM drills d
            WHERE d.execution_status = 'InProgress'
            ORDER BY d.start_date DESC
        `;
        const drillsRes = await pool.query(drillsQuery);
        const drills = drillsRes.rows;

        if (drills.length === 0) {
            return res.json([]);
        }

        const drillIds = drills.map(d => d.id);

        const progressDataQuery = `
            SELECT
                ds.drill_id,
                s.id as scenario_id,
                (SELECT json_agg(st.id) FROM steps st WHERE st.scenario_id = s.id) as steps,
                (SELECT json_agg(dcc.id) FROM drill_checkpoints dc JOIN drill_checkpoint_criteria dcc ON dc.id = dcc.checkpoint_id WHERE dc.drill_id = ds.drill_id AND dc.after_scenario_id = s.id) as criteria
            FROM drill_scenarios ds
            JOIN scenarios s ON ds.scenario_id = s.id
            WHERE ds.drill_id = ANY($1::text[]);
        `;

        const executionDataQuery = `
            SELECT drill_id, step_id, NULL as criterion_id, status FROM execution_steps WHERE drill_id = ANY($1::text[]) AND status LIKE 'Completed%'
            UNION ALL
            SELECT drill_id, NULL as step_id, criterion_id, status FROM execution_checkpoint_criteria WHERE drill_id = ANY($1::text[]) AND status IN ('Pass', 'Fail')
        `;

        const [progressDataRes, executionDataRes] = await Promise.all([
            pool.query(progressDataQuery, [drillIds]),
            pool.query(executionDataQuery, [drillIds])
        ]);

        const progressMap = {};
        progressDataRes.rows.forEach(row => {
            if (!progressMap[row.drill_id]) {
                progressMap[row.drill_id] = { total: 0, completed: 0 };
            }
            const stepIds = row.steps || [];
            const critIds = row.criteria || [];
            progressMap[row.drill_id].total += stepIds.length + critIds.length;
        });

        executionDataRes.rows.forEach(row => {
            if (progressMap[row.drill_id]) {
                progressMap[row.drill_id].completed++;
            }
        });

        const drillsWithProgress = drills.map(drill => {
            const progress = progressMap[drill.id];
            const percentage = (progress && progress.total > 0) ? (progress.completed / progress.total) * 100 : 100; // Default to 100 if no steps/criteria
            return {
                ...drill,
                progress: percentage
            };
        });

        res.json(drillsWithProgress);

    } catch (err) {
        console.error('Error fetching public drills list:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});


// REWRITTEN & FIXED: Endpoint to get full details for a single public drill
app.get('/api/public/drills/:id', async (req, res) => {
    const { id } = req.params;
    try {
        const drillRes = await pool.query("SELECT * FROM drills WHERE id = $1 AND execution_status = 'InProgress'", [id]);
        if (drillRes.rows.length === 0) {
            return res.status(404).json({ error: 'Drill not found or not in progress.' });
        }
        const drill = drillRes.rows[0];

        // Fetch related data in parallel
        const usersQuery = "SELECT id, username, role, first_name, last_name, description, first_name || ' ' || last_name AS fullname FROM users";
        const scenariosQuery = `
            SELECT s.id, s.name, s.role, s.application_name, s.attachment, s.type,
                   COALESCE((SELECT json_agg(steps.* ORDER BY steps.step_order) FROM steps WHERE steps.scenario_id = s.id), '[]'::json) as steps
            FROM scenarios s WHERE s.id IN (SELECT scenario_id FROM drill_scenarios WHERE drill_id = $1)
        `;
        const drillScenariosQuery = 'SELECT scenario_id, group_name, scenario_order FROM drill_scenarios WHERE drill_id = $1';
        const drillDepsQuery = 'SELECT scenario_id, depends_on_scenario_id FROM drill_scenario_dependencies WHERE drill_id = $1';
        const drillGroupDepsQuery = 'SELECT group_name, depends_on_group_name FROM drill_group_dependencies WHERE drill_id = $1';
        const checkpointsQuery = `
            SELECT dc.id, dc.title, dc.after_scenario_id,
                   COALESCE((SELECT json_agg(dcc.* ORDER BY dcc.criterion_order) FROM drill_checkpoint_criteria dcc WHERE dcc.checkpoint_id = dc.id), '[]'::json) as criteria
            FROM drill_checkpoints dc WHERE dc.drill_id = $1
        `;
        const executionDataQuery = `
            (SELECT step_id as id, status, started_at, completed_at, assignee, result_text FROM execution_steps WHERE drill_id = $1)
            UNION ALL
            (SELECT criterion_id as id, status, NULL as started_at, checked_at as completed_at, checked_by as assignee, NULL as result_text FROM execution_checkpoint_criteria WHERE drill_id = $1)
        `;
        const assignmentsQuery = 'SELECT step_id, assignee_id FROM drill_step_assignments WHERE drill_id = $1';

        const [
            usersRes, scenariosRes, drillScenariosRes, drillDepsRes, groupDepsRes, checkpointsRes, executionDataRes, assignmentsRes
        ] = await Promise.all([
            pool.query(usersQuery),
            pool.query(scenariosQuery, [id]),
            pool.query(drillScenariosQuery, [id]),
            pool.query(drillDepsQuery, [id]),
            // *** FIX: Đổi 'groupDepsQuery' thành 'drillGroupDepsQuery' ***
            pool.query(drillGroupDepsQuery, [id]),
            pool.query(checkpointsQuery, [id]),
            pool.query(executionDataQuery, [id]),
            pool.query(assignmentsQuery, [id])
        ]);

        // Process drill structure
        drill.scenarios = drillScenariosRes.rows
            .sort((a, b) => a.scenario_order - b.scenario_order)
            .map(s => {
                const dependsOn = drillDepsRes.rows
                    .filter(dep => dep.scenario_id === s.scenario_id)
                    .map(dep => dep.depends_on_scenario_id);
                return {
                    id: s.scenario_id,
                    group: s.group_name,
                    dependsOn
                };
        });

        drill.group_dependencies = groupDepsRes.rows.reduce((acc, curr) => {
            let group = acc.find(g => g.group === curr.group_name);
            if (!group) {
                group = { group: curr.group_name, dependsOn: [] };
                acc.push(group);
            }
            group.dependsOn.push(curr.depends_on_group_name);
            return acc;
        }, []);

        drill.checkpoints = checkpointsRes.rows.reduce((acc, cp) => {
            acc[cp.id] = cp;
            return acc;
        }, {});

        drill.step_assignments = assignmentsRes.rows.reduce((acc, a) => {
            acc[a.step_id] = a.assignee_id;
            return acc;
        }, {});

        // Process scenarios and steps (remove sensitive data like description)
        const scenariosMap = scenariosRes.rows.reduce((acc, s) => {
            s.steps.forEach(st => delete st.description); // Remove description for public view
            acc[s.id] = { ...s, application: s.application_name };
            return acc;
        }, {});

        const stepsMap = Object.values(scenariosMap).flatMap(s => s.steps).reduce((acc, st) => {
            acc[st.id] = st;
            return acc;
        }, {});

        // Process execution data
        const executionData = executionDataRes.rows.reduce((acc, exec) => {
            if (exec.id) acc[exec.id] = exec;
            return acc;
        }, {});

        res.json({
            drill,
            scenarios: scenariosMap,
            steps: stepsMap,
            users: usersRes.rows,
            executionData
        });

    } catch (err) {
        console.error(`Error fetching public drill details for ${id}:`, err);
        res.status(500).json({ error: 'Internal server error' });
    }
});


app.get('/api/scenarios/:id/attachment', async (req, res) => {
    const { id } = req.params;
    try {
        const result = await pool.query('SELECT attachment FROM scenarios WHERE id = $1', [id]);
        if (result.rows.length > 0 && result.rows[0].attachment) {
            res.json(result.rows[0].attachment);
        } else {
            res.status(404).json({ error: 'Attachment not found' });
        }
    } catch (err) {
        console.error('Error fetching scenario attachment:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// --- API QUẢN LÝ SERVER ---
app.get('/api/servers', async (req, res) => {
    try {
        const result = await pool.query(`
            SELECT
                s.id, s.hostname, s.ip_address, s.ssh_user,
                s.technologies as technology,
                s.application_name,
                s.connection_status as status,
                a.id as application_id,
                s.last_checked_at
            FROM managed_servers s
            LEFT JOIN applications a ON s.application_name = a.app_name
            ORDER BY s.hostname
        `);
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching servers:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/servers', async (req, res) => {
    const { hostname, ip_address, application_name, ssh_user, technologies, ssh_password, skip_key_registration } = req.body;
    if (ssh_password && !skip_key_registration) {
        try {
            await new Promise((resolve, reject) => {
                const escapedPassword = ssh_password.replace(/'/g, "'\\''");
                const registerKeyCommand = `sshpass -p '${escapedPassword}' ssh-copy-id -o StrictHostKeyChecking=no -o ConnectTimeout=10 ${ssh_user}@${ip_address}`;

                exec(registerKeyCommand, { timeout: 20000 }, (error, stdout, stderr) => {
                    if (error) {
                        console.error(`ssh-copy-id failed for ${ssh_user}@${ip_address}: ${stderr}`);
                        if (stderr.toLowerCase().includes('permission denied')) {
                            return reject(new Error('Sai mật khẩu hoặc xác thực thất bại.'));
                        }
                        return reject(new Error(`Không thể đăng ký public key: ${stderr || error.message}`));
                    }
                    console.log(`ssh-copy-id successful for ${ssh_user}@${ip_address}: ${stdout}`);
                    resolve(stdout);
                });
            });
        } catch (err) {
            return res.status(400).json({ error: err.message });
        }
    }

    try {
        const query = `
            INSERT INTO managed_servers (hostname, ip_address, application_name, ssh_user, technologies, connection_status)
            VALUES ($1, $2, $3, $4, $5, 'Not Connected') RETURNING *
        `;
        const result = await pool.query(query, [hostname, ip_address, application_name, ssh_user, technologies || [],]);
        res.status(201).json(result.rows[0]);
    } catch (err) {
        console.error('Error creating server in DB:', err);
        if (err.code === '23505') {
            return res.status(409).json({ error: 'Hostname hoặc IP đã tồn tại.' });
        }
        res.status(500).json({ error: 'Lỗi nội bộ khi lưu thông tin server.' });
    }
});


app.put('/api/servers/:id', async (req, res) => {
    const { id } = req.params;
    const { hostname, ip_address, application_name, ssh_user, technologies } = req.body;
    try {
        const query = `
            UPDATE managed_servers
            SET hostname = $1, ip_address = $2, application_name = $3, ssh_user = $4, technologies = $5, updated_at = NOW()
            WHERE id = $6 RETURNING *
        `;
        const result = await pool.query(query, [hostname, ip_address, application_name, ssh_user, technologies || [], id]);
        if (result.rows.length > 0) {
            res.json(result.rows[0]);
        } else {
            res.status(404).json({ error: 'Server not found' });
        }
    } catch (err) {
        console.error(`Error updating server ${id}:`, err);
         if (err.code === '23505') {
            return res.status(409).json({ error: 'Hostname đã tồn tại.' });
        }
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.delete('/api/servers/:id', async (req, res) => {
    const { id } = req.params;
    try {
        const result = await pool.query('DELETE FROM managed_servers WHERE id = $1', [id]);
        if (result.rowCount > 0) {
            res.status(204).send(); // No Content
        } else {
            res.status(404).json({ error: 'Server not found' });
        }
    } catch (err) {
        console.error(`Error deleting server ${id}:`, err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/servers/:id/check', async (req, res) => {
    const { id } = req.params;
    try {
        const serverRes = await pool.query('SELECT ip_address, ssh_user FROM managed_servers WHERE id = $1', [id]);
        if (serverRes.rows.length === 0) {
            return res.status(404).json({ error: 'Server not found' });
        }
        const { ip_address, ssh_user } = serverRes.rows[0];

        if (!ssh_user || !ip_address) {
            return res.status(400).json({ error: "SSH User and IP Address are required for testing."});
        }

        await pool.query("UPDATE managed_servers SET connection_status = 'Checking' WHERE id = $1", [id]);

        res.status(202).json({ message: 'Connection check initiated' });

        const sshCommand = `ssh -o StrictHostKeyChecking=no -o BatchMode=yes -o ConnectTimeout=10 ${ssh_user}@${ip_address} 'echo "OK"'`;

        exec(sshCommand, { timeout: 15000 }, async (error, stdout, stderr) => {
            let newStatus = 'Not Connected';

            if (error) {
                console.error(`SSH check failed for ${ssh_user}@${ip_address}: ${error.message}`);
                newStatus = 'Not Connected';
            } else if (stderr && !stderr.toLowerCase().includes('warning')) {
                console.error(`SSH check failed with stderr for ${ssh_user}@${ip_address}: ${stderr}`);
                newStatus = 'Not Connected';
            } else if (stdout && stdout.trim() === "OK") {
                console.log(`SSH check successful for ${ssh_user}@${ip_address}: ${stdout}`);
                newStatus = 'Connected';
            } else {
                console.log(`SSH check had unexpected output for ${ssh_user}@${ip_address}. stdout: ${stdout}, stderr: ${stderr}`);
                newStatus = 'Not Connected';
            }

            try {
                await pool.query("UPDATE managed_servers SET connection_status = $1, last_checked_at = NOW() WHERE id = $2", [newStatus, id]);
                console.log(`Test for server ${id} completed with status: ${newStatus}.`);
            } catch (dbError) {
                console.error(`Database error updating server ${id}:`, dbError);
            }
        });

    } catch (err) {
        console.error(`Error initiating connection test for server ${id}:`, err);
        if (!res.headersSent) {
            try {
                await pool.query("UPDATE managed_servers SET connection_status = 'Not Connected' WHERE id = $1", [id]);
            } catch (dbError) {
                console.error(`Database error setting server ${id} to Not Connected:`, dbError);
            }
            res.status(500).json({ error: 'Internal server error during check initiation.' });
        }
    }
});

// --- KẾT THÚC API QUẢN LÝ SERVER ---

// --- API QUẢN LÝ ỨNG DỤNG (APPLICATIONS) ---
app.get('/api/applications', async (req, res) => {
    try {
        const result = await pool.query('SELECT * FROM applications ORDER BY app_name ASC');
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching applications:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/applications', async (req, res) => {
    const { app_code, app_name, description } = req.body;
    try {
        const query = 'INSERT INTO applications (app_code, app_name, description) VALUES ($1, $2, $3) RETURNING *';
        const result = await pool.query(query, [app_code, app_name, description]);
        res.status(201).json(result.rows[0]);
    } catch (err) {
        console.error('Error creating application:', err);
        if (err.code === '23505') { // Unique violation
            return res.status(409).json({ error: 'Mã ứng dụng đã tồn tại.' });
        }
        res.status(500).json({ error: 'Could not create application' });
    }
});

app.put('/api/applications/:id', async (req, res) => {
    const { id } = req.params;
    const { app_code, app_name, description } = req.body;
    try {
        const query = 'UPDATE applications SET app_code = $1, app_name = $2, description = $3, updated_at = NOW() WHERE id = $4 RETURNING *';
        const result = await pool.query(query, [app_code, app_name, description, id]);
        if (result.rows.length > 0) {
            res.json(result.rows[0]);
        } else {
            res.status(404).json({ error: 'Application not found' });
        }
    } catch (err) {
        console.error('Error updating application:', err);
        if (err.code === '23505') { // Unique violation
            return res.status(409).json({ error: 'Mã ứng dụng đã tồn tại.' });
        }
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.delete('/api/applications/:id', async (req, res) => {
    const { id } = req.params;
    try {
        const result = await pool.query('DELETE FROM applications WHERE id = $1', [id]);
        if (result.rowCount > 0) {
            res.status(200).json({ message: 'Application deleted successfully' });
        } else {
            res.status(404).json({ error: 'Application not found' });
        }
    } catch (err) {
        console.error('Error deleting application:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});
// --- KẾT THÚC API QUẢN LÝ ỨNG DỤNG (APPLICATIONS) ---

// --- API XÁC THỰC, USER & CÀI ĐẶT ---

app.post('/api/login', async (req, res) => {
    const { username, password } = req.body;
    try {
        const result = await pool.query("SELECT *, first_name || ' ' || last_name AS fullname FROM users WHERE username = $1 AND password = $2", [username, password]);
        if (result.rows.length > 0) {
            const user = result.rows[0];
            res.json({ id: user.id, username: user.username, role: user.role, fullname: user.fullname });
        } else {
            res.status(401).json({ error: 'Invalid credentials' });
        }
    } catch (err) {
        console.error('Login error:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.get('/api/settings', async (req, res) => {
    try {
        const result = await pool.query("SELECT * FROM app_settings WHERE key = 'sessionTimeout'");
        if (result.rows.length > 0) {
            res.json({ sessionTimeout: parseInt(result.rows[0].value, 10) });
        } else {
            res.json({ sessionTimeout: 30 });
        }
    } catch (err) {
        console.error('Error fetching settings:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/admin/settings', async (req, res) => {
    const { sessionTimeout } = req.body;
    try {
        const query = `
            INSERT INTO app_settings (key, value)
            VALUES ('sessionTimeout', $1)
            ON CONFLICT (key) DO UPDATE SET value = $1;
        `;
        await pool.query(query, [sessionTimeout.toString()]);
        res.status(200).json({ message: 'Settings saved successfully' });
    } catch (err) {
        console.error('Save settings error:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/users', async (req, res) => {
    const { username, role, first_name, last_name, description, password } = req.body;
    try {
        const newUser = await pool.query(
            'INSERT INTO users (id, username, password, role, first_name, last_name, description) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, username, role, first_name, last_name, description',
            [`user-${Date.now()}`, username, password || 'password', role, first_name, last_name, description]
        );
        res.status(201).json(newUser.rows[0]);
    } catch (err) {
        console.error('Create user error:', err);
        res.status(500).json({ error: 'Could not create user' });
    }
});

app.put('/api/users/:id', async (req, res) => {
    const { id } = req.params;
    const { username, role, first_name, last_name, description } = req.body;
    try {
        const result = await pool.query(
            'UPDATE users SET username = $1, role = $2, first_name = $3, last_name = $4, description = $5 WHERE id = $6 RETURNING id, username, role, first_name, last_name, description',
            [username, role, first_name, last_name, description, id]
        );
        if (result.rows.length > 0) res.json(result.rows[0]);
        else res.status(404).json({ error: 'User not found' });
    } catch (err) {
        console.error('Update user error:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.put('/api/users/:id/password', async (req, res) => {
    const { id } = req.params;
    const { new_password } = req.body;
    if (!new_password) return res.status(400).json({ error: 'New password is required' });
    try {
        await pool.query('UPDATE users SET password = $1 WHERE id = $2', [new_password, id]);
        res.status(200).json({ message: 'Password updated successfully' });
    } catch (err) {
        console.error('Admin password reset error:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/user/change-password', async (req, res) => {
    const { userId, oldPassword, newPassword } = req.body;
    try {
        const userResult = await pool.query('SELECT password FROM users WHERE id = $1', [userId]);
        if (userResult.rows.length === 0) {
            return res.status(404).json({ error: 'User not found' });
        }
        if (userResult.rows[0].password !== oldPassword) {
            return res.status(403).json({ error: 'Incorrect old password' });
        }
        await pool.query('UPDATE users SET password = $1 WHERE id = $2', [newPassword, userId]);
        res.status(200).json({ message: 'Password changed successfully' });
    } catch (err) {
        console.error('User change password error:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});


// --- API QUẢN LÝ KỊCH BẢN (SCENARIOS) ---

app.post('/api/scenarios', async (req, res) => {
    const { name, role, basis, status, created_by, steps, attachment, applicationName, type } = req.body;
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        const scenarioId = `scen-${Date.now()}`;
        const scenarioQuery = 'INSERT INTO scenarios (id, name, role, basis, status, created_by, attachment, application_name, type) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING *';
        await client.query(scenarioQuery, [scenarioId, name, role, basis, status, created_by, attachment ? JSON.stringify(attachment) : null, applicationName, type]);

        if (steps && steps.length > 0) {
            const tempIdToDbId = {};
            for (const [index, step] of steps.entries()) {
                const stepId = `step-${Date.now()}-${index}`;
                tempIdToDbId[step.id] = stepId;
                step.dbId = stepId; // Store dbId for dependency linking

                if (type === 'AUTOMATION') {
                    const stepQuery = 'INSERT INTO steps (id, scenario_id, title, step_order, server_id, server_user, command) VALUES ($1, $2, $3, $4, $5, $6, $7)';
                    await client.query(stepQuery, [stepId, scenarioId, step.title, index + 1, step.server_id, step.server_user, step.command]);
                } else { // MANUAL
                    const stepQuery = 'INSERT INTO steps (id, scenario_id, title, description, estimated_time, step_order) VALUES ($1, $2, $3, $4, $5, $6)';
                    await client.query(stepQuery, [stepId, scenarioId, step.title, step.description, step.estimated_time, index + 1]);
                }
            }
            // Add dependencies after all steps are created
            for (const step of steps) {
                if (step.dependsOn && step.dependsOn.length > 0) {
                    for (const depTempId of step.dependsOn) {
                        const depDbId = tempIdToDbId[depTempId];
                        if (depDbId) {
                            const depQuery = 'INSERT INTO step_dependencies (step_id, depends_on_step_id) VALUES ($1, $2)';
                            await client.query(depQuery, [step.dbId, depDbId]);
                        } else {
                            console.warn(`Dependency ${depTempId} not found for step ${step.dbId}`);
                        }
                    }
                }
            }
        }
        await client.query('COMMIT');
        res.status(201).json({ message: 'Scenario created successfully' });
    } catch (err) {
        await client.query('ROLLBACK');
        console.error('Create scenario error:', err);
        res.status(500).json({ error: 'Internal server error' });
    } finally {
        client.release();
    }
});


app.put('/api/scenarios/:id', async (req, res) => {
    const { id } = req.params;
    const { name, role, basis, status, steps, attachment, applicationName, type } = req.body;
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        const scenarioQuery = `
            UPDATE scenarios
            SET name = $1, role = $2, basis = $3, status = $4, last_updated_at = NOW(), attachment = $5, application_name = $6, type = $7
            WHERE id = $8
        `;
        await client.query(scenarioQuery, [name, role, basis, status, attachment ? JSON.stringify(attachment) : null, applicationName, type, id]);

        // Clean up old steps and dependencies
        await client.query('DELETE FROM step_dependencies WHERE step_id IN (SELECT id FROM steps WHERE scenario_id = $1)', [id]);
        await client.query('DELETE FROM steps WHERE scenario_id = $1', [id]);

        if (steps && steps.length > 0) {
            const tempIdToDbId = {};
            for (const [index, step] of steps.entries()) {
                // Use existing ID if it starts with 'step-', otherwise generate new
                const stepId = step.id && step.id.startsWith('step-') ? step.id : `step-${Date.now()}-${index}`;
                tempIdToDbId[step.id] = stepId; // Map original ID (temp or existing) to current DB ID
                step.dbId = stepId; // Store current DB ID for dependency linking

                if (type === 'AUTOMATION') {
                     const stepQuery = 'INSERT INTO steps (id, scenario_id, title, step_order, server_id, server_user, command) VALUES ($1, $2, $3, $4, $5, $6, $7)';
                    await client.query(stepQuery, [stepId, id, step.title, index + 1, step.server_id, step.server_user, step.command]);
                } else { // MANUAL
                    const stepQuery = 'INSERT INTO steps (id, scenario_id, title, description, estimated_time, step_order) VALUES ($1, $2, $3, $4, $5, $6)';
                    await client.query(stepQuery, [stepId, id, step.title, step.description, step.estimated_time, index + 1]);
                }
            }
             // Add dependencies after all steps are created/re-created
             for (const step of steps) {
                if (step.dependsOn && step.dependsOn.length > 0) {
                    for (const depTempId of step.dependsOn) {
                        const depDbId = tempIdToDbId[depTempId]; // Find the *current* DB ID of the dependency
                        if (depDbId) {
                            const depQuery = 'INSERT INTO step_dependencies (step_id, depends_on_step_id) VALUES ($1, $2)';
                            await client.query(depQuery, [step.dbId, depDbId]);
                        } else {
                             console.warn(`Dependency ${depTempId} not found for step ${step.dbId} during update`);
                        }
                    }
                }
            }
        }
        await client.query('COMMIT');
        res.status(200).json({ message: 'Scenario updated successfully' });
    } catch (err) {
        await client.query('ROLLBACK');
        console.error('Update scenario error:', err);
        res.status(500).json({ error: 'Internal server error' });
    } finally {
        client.release();
    }
});


app.put('/api/scenarios/:id/status', async (req, res) => {
    const { id } = req.params;
    const { status } = req.body;
    try {
        const result = await pool.query(
            'UPDATE scenarios SET status = $1, last_updated_at = NOW() WHERE id = $2 RETURNING *',
            [status, id]
        );
        if (result.rows.length > 0) res.json(result.rows[0]);
        else res.status(404).json({ error: 'Scenario not found' });
    } catch (err) {
        console.error('Update scenario status error:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.delete('/api/scenarios/:id', async (req, res) => {
    const { id } = req.params;
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        // Delete dependencies first
        await client.query('DELETE FROM drill_scenario_dependencies WHERE scenario_id = $1 OR depends_on_scenario_id = $1', [id]);
        // Find related checkpoints
        const checkpointIdsQuery = 'SELECT id FROM drill_checkpoints WHERE after_scenario_id = $1';
        const checkpointIdsResult = await client.query(checkpointIdsQuery, [id]);
        const checkpointIds = checkpointIdsResult.rows.map(r => r.id);
        // Delete related checkpoint execution data, criteria, and checkpoints
        if(checkpointIds.length > 0) {
            await client.query('DELETE FROM execution_checkpoint_criteria WHERE criterion_id IN (SELECT id FROM drill_checkpoint_criteria WHERE checkpoint_id = ANY($1::text[]))', [checkpointIds]);
            await client.query('DELETE FROM drill_checkpoint_criteria WHERE checkpoint_id = ANY($1::text[])', [checkpointIds]);
            await client.query('DELETE FROM drill_checkpoints WHERE id = ANY($1::text[])', [checkpointIds]);
        }
        // Delete scenario from drills
        await client.query('DELETE FROM drill_scenarios WHERE scenario_id = $1', [id]);
        // Delete step dependencies
        await client.query('DELETE FROM step_dependencies WHERE step_id IN (SELECT id FROM steps WHERE scenario_id = $1)', [id]);
        // Delete step execution data
        await client.query('DELETE FROM execution_steps WHERE step_id IN (SELECT id FROM steps WHERE scenario_id = $1)', [id]);
        // Delete scenario execution data
        await client.query('DELETE FROM execution_scenarios WHERE scenario_id = $1', [id]);
        // Delete steps
        await client.query('DELETE FROM steps WHERE scenario_id = $1', [id]);
        // Finally, delete the scenario itself
        const result = await client.query('DELETE FROM scenarios WHERE id = $1', [id]);
        await client.query('COMMIT');

        if (result.rowCount > 0) {
            res.status(200).json({ message: 'Scenario deleted successfully' });
        } else {
            res.status(404).json({ error: 'Scenario not found' });
        }
    } catch (err) {
        await client.query('ROLLBACK');
        console.error('Delete scenario error:', err);
        res.status(500).json({ error: 'Internal server error' });
    } finally {
        client.release();
    }
});

// --- START: API MỚI ĐỂ KÍCH HOẠT CHẠY THỬ ---
app.post('/api/scenarios/:id/test_run', async (req, res) => {
    const { id: scenarioId } = req.params;

    if (activeTestRuns.has(scenarioId)) {
        return res.status(409).json({ message: 'Một phiên chạy thử cho kịch bản này đã được thực hiện.' });
    }

    try {
        // Lấy thông tin scenario để kiểm tra
        const scenarioRes = await pool.query('SELECT type FROM scenarios WHERE id = $1', [scenarioId]);
        if (scenarioRes.rows.length === 0) {
            return res.status(404).json({ error: 'Kịch bản không tồn tại.' });
        }
        if (scenarioRes.rows[0].type !== 'AUTOMATION') {
            return res.status(400).json({ error: 'Chỉ có thể chạy thử kịch bản Tự động.' });
        }
        
        // Đánh dấu là đang chạy
        activeTestRuns.set(scenarioId, { status: 'running' });

        // Gửi 202 Accepted ngay lập tức, và chạy test trong background
        res.status(202).json({ message: 'Đã chấp nhận yêu cầu chạy thử. Đang kết nối...' });
        
        // Chạy hàm test (không await)
        runScenarioTest(scenarioId); 

    } catch (err) {
        console.error(`[Test Run ${scenarioId}]: Lỗi khi bắt đầu (API):`, err);
        activeTestRuns.delete(scenarioId); // Dọn dẹp nếu có lỗi ngay
        if (!res.headersSent) {
            res.status(500).json({ error: 'Lỗi máy chủ nội bộ khi chuẩn bị chạy thử.' });
        }
    }
});
// --- END: API MỚI ĐỂ KÍCH HOẠT CHẠY THỬ ---


// --- API QUẢN LÝ DIỄN TẬP (DRILLS) ---

app.post('/api/drills', async (req, res) => {
    const { name, description, basis, status, start_date, end_date, scenarios, step_assignments, checkpoints, group_dependencies } = req.body;
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        const drillId = `drill-${Date.now()}`;
        const drillQuery = 'INSERT INTO drills (id, name, description, basis, status, start_date, end_date, execution_status) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)';
        await client.query(drillQuery, [drillId, name, description, basis, status, start_date, end_date, 'Scheduled']);

        if (scenarios && scenarios.length > 0) {
            for (const [index, scen] of scenarios.entries()) {
                await client.query('INSERT INTO drill_scenarios (drill_id, scenario_id, scenario_order, group_name) VALUES ($1, $2, $3, $4)', [drillId, scen.id, index + 1, scen.group]);
                if (scen.dependsOn && scen.dependsOn.length > 0) {
                    for (const depId of scen.dependsOn) {
                        await client.query('INSERT INTO drill_scenario_dependencies (drill_id, scenario_id, depends_on_scenario_id) VALUES ($1, $2, $3)', [drillId, scen.id, depId]);
                    }
                }
            }
        }

        if (group_dependencies && group_dependencies.length > 0) {
            for (const dep of group_dependencies) {
                if(dep.dependsOn && dep.dependsOn.length > 0) {
                    for (const depName of dep.dependsOn) {
                        await client.query('INSERT INTO drill_group_dependencies (drill_id, group_name, depends_on_group_name) VALUES ($1, $2, $3)', [drillId, dep.group, depName]);
                    }
                }
            }
        }

        if (step_assignments) {
            for (const [stepId, assigneeId] of Object.entries(step_assignments)) {
                if (assigneeId) { // Only insert if assignee is selected
                    await client.query('INSERT INTO drill_step_assignments (drill_id, step_id, assignee_id) VALUES ($1, $2, $3)', [drillId, stepId, assigneeId]);
                }
            }
        }

        if (checkpoints) {
            for (const [scenarioId, cp] of Object.entries(checkpoints)) {
                if (cp && cp.title) { // Check if checkpoint exists and has a title
                    const checkpointId = `cp-${Date.now()}-${scenarioId}`;
                    await client.query('INSERT INTO drill_checkpoints (id, drill_id, after_scenario_id, title) VALUES ($1, $2, $3, $4)', [checkpointId, drillId, scenarioId, cp.title]);
                    if (cp.criteria && cp.criteria.length > 0) {
                        for (const [index, criterion] of cp.criteria.entries()) {
                            if (criterion.text) { // Check if criterion has text
                                const criterionId = `crit-${Date.now()}-${index}`;
                                await client.query('INSERT INTO drill_checkpoint_criteria (id, checkpoint_id, criterion_text, criterion_order) VALUES ($1, $2, $3, $4)', [criterionId, checkpointId, criterion.text, index + 1]);
                            }
                        }
                    }
                }
            }
        }

        await client.query('COMMIT');
        res.status(201).json({ message: 'Drill created successfully' });
    } catch (err) {
        await client.query('ROLLBACK');
        console.error('Create drill error:', err);
        res.status(500).json({ error: 'Internal server error' });
    } finally {
        client.release();
    }
});


app.put('/api/drills/:id', async (req, res) => {
    const { id } = req.params;
    const { name, description, basis, status, start_date, end_date, scenarios, step_assignments, checkpoints, group_dependencies } = req.body;
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        const drillQuery = 'UPDATE drills SET name = $1, description = $2, basis = $3, status = $4, start_date = $5, end_date = $6 WHERE id = $7';
        await client.query(drillQuery, [name, description, basis, status, start_date, end_date, id]);

        // Clean up relations before inserting new ones
        await client.query('DELETE FROM drill_group_dependencies WHERE drill_id = $1', [id]);
        await client.query('DELETE FROM drill_scenario_dependencies WHERE drill_id = $1', [id]);
        await client.query('DELETE FROM drill_scenarios WHERE drill_id = $1', [id]);
        await client.query('DELETE FROM drill_step_assignments WHERE drill_id = $1', [id]);
        // Find and delete old checkpoint criteria and checkpoints
        const oldCheckpointIdsQuery = 'SELECT id FROM drill_checkpoints WHERE drill_id = $1';
        const oldCheckpointIdsResult = await client.query(oldCheckpointIdsQuery, [id]);
        const oldCheckpointIds = oldCheckpointIdsResult.rows.map(r => r.id);
        if(oldCheckpointIds.length > 0) {
            await client.query('DELETE FROM drill_checkpoint_criteria WHERE checkpoint_id = ANY($1::text[])', [oldCheckpointIds]);
            await client.query('DELETE FROM drill_checkpoints WHERE drill_id = $1', [id]);
        }

        // Insert new relations
        if (scenarios && scenarios.length > 0) {
            for (const [index, scen] of scenarios.entries()) {
                await client.query('INSERT INTO drill_scenarios (drill_id, scenario_id, scenario_order, group_name) VALUES ($1, $2, $3, $4)', [id, scen.id, index + 1, scen.group]);
                if (scen.dependsOn && scen.dependsOn.length > 0) {
                    for (const depId of scen.dependsOn) {
                        await client.query('INSERT INTO drill_scenario_dependencies (drill_id, scenario_id, depends_on_scenario_id) VALUES ($1, $2, $3)', [id, scen.id, depId]);
                    }
                }
            }
        }

        if (group_dependencies && group_dependencies.length > 0) {
            for (const dep of group_dependencies) {
                 if(dep.dependsOn && dep.dependsOn.length > 0) {
                    for (const depName of dep.dependsOn) {
                        await client.query('INSERT INTO drill_group_dependencies (drill_id, group_name, depends_on_group_name) VALUES ($1, $2, $3)', [id, dep.group, depName]);
                    }
                }
            }
        }

        if (step_assignments) {
            for (const [stepId, assigneeId] of Object.entries(step_assignments)) {
                if (assigneeId) { // Only insert if assignee is selected
                    await client.query('INSERT INTO drill_step_assignments (drill_id, step_id, assignee_id) VALUES ($1, $2, $3)', [id, stepId, assigneeId]);
                }
            }
        }

        if (checkpoints) {
            for (const [scenarioId, cp] of Object.entries(checkpoints)) {
                 if (cp && cp.title) { // Check if checkpoint exists and has a title
                    const checkpointId = `cp-${Date.now()}-${scenarioId}`;
                    await client.query('INSERT INTO drill_checkpoints (id, drill_id, after_scenario_id, title) VALUES ($1, $2, $3, $4)', [checkpointId, id, scenarioId, cp.title]);
                    if (cp.criteria && cp.criteria.length > 0) {
                        for (const [index, criterion] of cp.criteria.entries()) {
                            if (criterion.text) { // Check if criterion has text
                                const criterionId = `crit-${Date.now()}-${index}`;
                                await client.query('INSERT INTO drill_checkpoint_criteria (id, checkpoint_id, criterion_text, criterion_order) VALUES ($1, $2, $3, $4)', [criterionId, checkpointId, criterion.text, index + 1]);
                            }
                        }
                    }
                }
            }
        }

        await client.query('COMMIT');
        res.status(200).json({ message: 'Drill updated successfully' });
    } catch (err) {
        await client.query('ROLLBACK');
        console.error('Update drill error:', err);
        res.status(500).json({ error: 'Internal server error' });
    } finally {
        client.release();
    }
});


// --- API THỰC THI & GHI NHẬN KẾT QUẢ ---

app.put('/api/drills/:id/status', async (req, res) => {
    const { id } = req.params;
    const { execution_status, timestamp, reason } = req.body;
    let query;
    if (execution_status === 'InProgress') {
        query = { text: 'UPDATE drills SET execution_status = $1, opened_at = $2 WHERE id = $3 RETURNING *', values: [execution_status, timestamp, id] };
    } else if (execution_status === 'Closed' || execution_status === 'Failed') {
        query = {
            text: 'UPDATE drills SET execution_status = $1, closed_at = $2, failure_reason = $3 WHERE id = $4 RETURNING *',
            values: [execution_status, timestamp, reason || null, id]
        };
    } else {
        return res.status(400).json({ error: 'Invalid status' });
    }
    try {
        const result = await pool.query(query);
        if (result.rows.length > 0) res.json(result.rows[0]);
        else res.status(404).json({ error: 'Drill not found' });
    } catch (err) {
        console.error('Update drill status error:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/execution/step', async (req, res) => {
    const { drill_id, step_id, status, started_at, completed_at, assignee, result_text } = req.body;
    try {
        const query = `
            INSERT INTO execution_steps (drill_id, step_id, status, started_at, completed_at, assignee, result_text)
            VALUES ($1, $2, $3, $4, $5, $6, $7)
            ON CONFLICT (drill_id, step_id)
            DO UPDATE SET
                status = EXCLUDED.status,
                started_at = COALESCE(execution_steps.started_at, EXCLUDED.started_at),
                completed_at = EXCLUDED.completed_at,
                assignee = COALESCE(execution_steps.assignee, EXCLUDED.assignee),
                result_text = EXCLUDED.result_text
            RETURNING *;
        `;
        const result = await pool.query(query, [drill_id, step_id, status, started_at, completed_at, assignee, result_text]);
        res.status(201).json(result.rows[0]);
    } catch (err) {
        console.error('Upsert execution step error:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/execution/scenario', async (req, res) => {
    const { drill_id, scenario_id, final_status, final_reason } = req.body;
    try {
        const query = `
            INSERT INTO execution_scenarios (drill_id, scenario_id, final_status, final_reason)
            VALUES ($1, $2, $3, $4)
            ON CONFLICT (drill_id, scenario_id)
            DO UPDATE SET final_status = EXCLUDED.final_status, final_reason = EXCLUDED.final_reason
            RETURNING *;
        `;
        const result = await pool.query(query, [drill_id, scenario_id, final_status, final_reason]);
        res.status(201).json(result.rows[0]);
    } catch (err) {
        console.error('Upsert execution scenario error:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/execution/checkpoint', async (req, res) => {
    const { drill_id, criterion_id, status, checked_by } = req.body;
    try {
        const query = `
            INSERT INTO execution_checkpoint_criteria (drill_id, criterion_id, status, checked_by, checked_at)
            VALUES ($1, $2, $3, $4, NOW())
            ON CONFLICT (drill_id, criterion_id)
            DO UPDATE SET status = EXCLUDED.status, checked_by = EXCLUDED.checked_by, checked_at = NOW()
            RETURNING *;
        `;
        const result = await pool.query(query, [drill_id, criterion_id, status, checked_by]);
        res.status(201).json(result.rows[0]);
    } catch (err) {
        console.error('Upsert execution checkpoint error:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// --- API QUẢN TRỊ HỆ THỐNG ---

app.post('/api/admin/cleanup-history', async (req, res) => {
    const { months } = req.body;
    if (![3, 6, 12].includes(parseInt(months))) {
        return res.status(400).json({ error: 'Invalid time period.' });
    }
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        const cutoffDate = new Date();
        cutoffDate.setMonth(cutoffDate.getMonth() - parseInt(months));
        const drillsToDeleteQuery = `SELECT id FROM drills WHERE (execution_status = 'Closed' OR execution_status = 'Failed') AND closed_at < $1`;
        const drillsResult = await client.query(drillsToDeleteQuery, [cutoffDate]);
        const drillIdsToDelete = drillsResult.rows.map(r => r.id);
        if (drillIdsToDelete.length > 0) {
            await client.query('DELETE FROM execution_steps WHERE drill_id = ANY($1::text[])', [drillIdsToDelete]);
            await client.query('DELETE FROM execution_scenarios WHERE drill_id = ANY($1::text[])', [drillIdsToDelete]);
            await client.query('DELETE FROM execution_checkpoint_criteria WHERE drill_id = ANY($1::text[])', [drillIdsToDelete]);
        }
        await client.query('COMMIT');
        res.status(200).json({ message: `Successfully cleaned up execution data for ${drillIdsToDelete.length} drills.` });
    } catch (err) {
        await client.query('ROLLBACK');
        console.error('Cleanup history error:', err);
        res.status(500).json({ error: 'Internal server error' });
    } finally {
        client.release();
    }
});

app.post('/api/admin/reset-system', async (req, res) => {
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        await client.query('TRUNCATE drills, drill_scenarios, drill_scenario_dependencies, execution_steps, execution_scenarios, drill_step_assignments, drill_checkpoints, drill_checkpoint_criteria, execution_checkpoint_criteria RESTART IDENTITY');
        await client.query('COMMIT');
        res.status(200).json({ message: 'System has been reset successfully.' });
    } catch (err) {
        await client.query('ROLLBACK');
        console.error('System reset error:', err);
        res.status(500).json({ error: 'Internal server error' });
    } finally {
        client.release();
    }
});

app.post('/api/admin/seed-demo-data', async (req, res) => {
    const client = await pool.connect();
    try {
        await client.query('BEGIN');

        await client.query(`
            INSERT INTO users (id, username, password, role, first_name, last_name, description) VALUES
            ('user-1', 'admin', 'password', 'ADMIN', 'Admin', 'User', 'System Administrator'),
            ('user-2', 'tech_user', 'password', 'TECHNICAL', 'Tech', 'User', 'Database Specialist'),
            ('user-3', 'biz_user', 'password', 'BUSINESS', 'User', 'Communications Lead')
            ON CONFLICT (id) DO UPDATE SET
                username = EXCLUDED.username,
                password = EXCLUDED.password,
                role = EXCLUDED.role,
                first_name = EXCLUDED.first_name,
                last_name = EXCLUDED.last_name,
                description = EXCLUDED.description;
        `);

        await client.query(`
            INSERT INTO scenarios (id, name, role, created_by, created_at, last_updated_at, status, basis, application_name) VALUES
            ('scen-1', 'Chuyển đổi dự phòng Database', 'TECHNICAL', 'user-2', '2025-08-10T10:00:00Z', '2025-08-11T14:30:00Z', 'Active', 'Kế hoạch DR năm 2025', 'Core Banking'),
            ('scen-2', 'Truyền thông Khách hàng', 'BUSINESS', 'user-3', '2025-08-10T11:00:00Z', '2025-08-10T11:00:00Z', 'Active', 'Kế hoạch DR năm 2025', 'Website'),
            ('scen-3', 'Kiểm tra hiệu năng hệ thống', 'TECHNICAL', 'user-2', '2025-08-11T09:00:00Z', '2025-08-12T11:00:00Z', 'Draft', '', 'Mobile App')
            ON CONFLICT (id) DO NOTHING;
        `);

        await client.query(`
            INSERT INTO steps (id, scenario_id, title, description, estimated_time, step_order) VALUES
            ('step-101', 'scen-1', 'Khởi tạo nâng cấp Read Replica của RDS', 'Promote the standby RDS instance in us-west-2 to become the new primary.', '00:15:00', 1),
            ('step-102', 'scen-1', 'Cập nhật bản ghi DNS', 'Point the primary DB CNAME record to the new primary instance endpoint.', '00:05:00', 2),
            ('step-103', 'scen-1', 'Xác minh kết nối ứng dụng', 'Run health checks on all critical applications to ensure they can connect to the new database.', '00:10:00', 3),
            ('step-201', 'scen-2', 'Soạn thảo cập nhật trạng thái nội bộ', 'Prepare an internal communication for all staff about the ongoing DR drill.', '00:20:00', 1),
            ('step-202', 'scen-2', 'Đăng lên trang trạng thái công khai', 'Update the public status page to inform customers about scheduled maintenance (simulated).', '00:05:00', 2),
            ('step-301', 'scen-3', 'Chạy bài test tải', 'Use JMeter to run a load test against the new primary application servers.', '01:00:00', 1)
            ON CONFLICT (id) DO NOTHING;
        `);

        await client.query(`
            INSERT INTO step_dependencies (step_id, depends_on_step_id) VALUES
            ('step-102', 'step-101'),
            ('step-103', 'step-102'),
            ('step-202', 'step-201')
            ON CONFLICT (step_id, depends_on_step_id) DO NOTHING;
        `);

        await client.query(`
            INSERT INTO drills (id, name, description, status, execution_status, basis, start_date, end_date, opened_at, closed_at) VALUES
            ('drill-1', 'Diễn tập chuyển đổi dự phòng AWS Quý 3', 'Mô phỏng chuyển đổi dự phòng toàn bộ khu vực cho các dịch vụ quan trọng.', 'Active', 'InProgress', 'Quyết định số 123/QĐ-NHNN ngày 01/01/2025', '2025-08-16', '2025-08-18', '2025-08-16T10:00:00Z', NULL)
            ON CONFLICT (id) DO NOTHING;
        `);

        await client.query(`
            INSERT INTO drill_scenarios (drill_id, scenario_id, scenario_order) VALUES
            ('drill-1', 'scen-1', 1),
            ('drill-1', 'scen-2', 2)
            ON CONFLICT (drill_id, scenario_id) DO NOTHING;
        `);

        await client.query(`
            INSERT INTO drill_scenario_dependencies (drill_id, scenario_id, depends_on_scenario_id) VALUES
            ('drill-1', 'scen-2', 'scen-1')
            ON CONFLICT (drill_id, scenario_id, depends_on_scenario_id) DO NOTHING;
        `);

        await client.query(`
            INSERT INTO drill_step_assignments (drill_id, step_id, assignee_id) VALUES
            ('drill-1', 'step-101', 'user-2'),
            ('drill-1', 'step-102', 'user-2'),
            ('drill-1', 'step-103', 'user-2'),
            ('drill-1', 'step-201', 'user-3'),
            ('drill-1', 'step-202', 'user-3')
            ON CONFLICT (drill_id, step_id) DO NOTHING;
        `);

        await client.query(`
            INSERT INTO execution_steps (drill_id, step_id, status, started_at, completed_at, assignee) VALUES
            ('drill-1', 'step-101', 'Completed-Success', '2025-08-16T10:00:00Z', '2025-08-16T10:14:00Z', 'user-2'),
            ('drill-1', 'step-102', 'InProgress', '2025-08-16T10:15:00Z', NULL, 'user-2'),
            ('drill-1', 'step-201', 'Completed-Success', '2025-08-16T10:16:00Z', '2025-08-16T10:20:00Z', 'user-3')
            ON CONFLICT (drill_id, step_id) DO UPDATE SET
                status = EXCLUDED.status,
                started_at = EXCLUDED.started_at,
                completed_at = EXCLUDED.completed_at,
                assignee = EXCLUDED.assignee;
        `);

        await client.query('COMMIT');
        res.status(200).json({ message: 'Demo data seeded successfully.' });
    } catch (err) {
        await client.query('ROLLBACK');
        console.error('Seed demo data error:', err);
        res.status(500).json({ error: 'Internal server error' });
    } finally {
        client.release();
    }
});


// --- Phục vụ Frontend ---
app.use(express.static(path.join(__dirname, 'client/build')));
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'client/build', 'index.html'));
});

// --- START: Helper functions cho Test Run ---
// Hàm thực thi một bước chạy thử (tương tự executeStep nhưng đơn giản hơn)
async function executeTestRunStep(scenarioId, step) {
    const { command, server_user, ip_address } = step;

    // --- SỬA LỖI: Thêm '\n' vào cuối mỗi log thủ công ---
    // (Chúng ta giả định hàm sendTestRunWsMessage đã strip ANSI codes)
    sendTestRunWsMessage(scenarioId, `\n--- Bắt đầu bước: ${step.title} ---\n`);
    sendTestRunWsMessage(scenarioId, `[INFO] Server: ${ip_address}, User: ${server_user}\n`);
    sendTestRunWsMessage(scenarioId, `[CMD] ${command}\n`); // Thêm \n ở đây

    if (!command || !server_user || !ip_address) {
        const errorMsg = "[ERROR] Lỗi cấu hình: Thiếu lệnh, user hoặc IP server.\n"; // Thêm \n
        sendTestRunWsMessage(scenarioId, errorMsg);
        throw new Error("Lỗi cấu hình bước"); // Reject a promise
    }

    return new Promise((resolve, reject) => {
        let ptyError = null;
        let exitHandled = false;

        const ptyProcess = pty.spawn('ssh', [`${server_user}@${ip_address}`, '-o', 'StrictHostKeyChecking=no', '-o', 'ConnectTimeout=10', command], {
            name: 'xterm-color', cols: 80, rows: 30, cwd: process.env.HOME, env: process.env
        });

        // Thêm process vào map để có thể kill nếu cần (tạm thời chưa dùng)
        // activeTestRuns.get(scenarioId).process = ptyProcess;

        ptyProcess.onData(data => {
            sendTestRunWsMessage(scenarioId, data); // Gửi log thô (đã strip ANSI)
        });

        ptyProcess.onExit(({ exitCode }) => {
            if (exitHandled) return;
            exitHandled = true;

            if (exitCode === 0) {
                sendTestRunWsMessage(scenarioId, `\n[SUCCESS] Bước hoàn thành (Exit Code 0).\n`); // Thêm \n
                resolve();
            } else {
                let errorMsg = `\n[FAILED] Bước thất bại (Exit Code ${exitCode}).\n`; // Thêm \n
                if (ptyError) {
                    errorMsg += `[Pty Error] ${ptyError.message}\n`; // Thêm \n
                }
                sendTestRunWsMessage(scenarioId, errorMsg);
                reject(new Error(`Bước thất bại với exit code ${exitCode}`));
            }
        });

        ptyProcess.on('error', (err) => {
            console.error(`[Test Run ${scenarioId}]: Pty process error:`, err);
            ptyError = err; // Ghi lại lỗi
            
            // Nếu lỗi EIO (thường gặp) thì đợi onExit xử lý,
            // Nếu lỗi khác (ví dụ: command not found) thì xử lý ngay
            if (err.code !== 'EIO' && !exitHandled) {
                exitHandled = true;
                const errorMsg = `\n[CRITICAL FAILED] Lỗi thực thi: ${err.message}.\n`; // Thêm \n
                sendTestRunWsMessage(scenarioId, errorMsg);
                reject(err);
            }
        });
    });
}

// Hàm chạy toàn bộ kịch bản (được gọi bởi API POST)
async function runScenarioTest(scenarioId) {
    let steps = [];
    try {
        const stepsRes = await pool.query(
            `SELECT s.*, ms.ip_address, ms.ssh_user FROM steps s
             LEFT JOIN managed_servers ms ON s.server_id = ms.id
             WHERE s.scenario_id = $1 ORDER BY s.step_order`, [scenarioId]
        );
        steps = stepsRes.rows;

        sendTestRunWsMessage(scenarioId, `\x1b[1m*** BẮT ĐẦU CHẠY THỬ (ID: ${scenarioId}) ***\x1b[0m`);
        sendTestRunWsMessage(scenarioId, `\x1b[1m*** Tổng số bước: ${steps.length} ***\x1b[0m`);

        // Chạy tuần tự
        for (const step of steps) {
            // Kiểm tra xem test run có bị hủy không (nếu cần)
            if (!activeTestRuns.has(scenarioId)) {
                sendTestRunWsMessage(scenarioId, "\x1b[33m[INFO]\x1b[0m Chạy thử đã bị hủy.");
                break;
            }
            await executeTestRunStep(scenarioId, step);
            // Nếu executeTestRunStep throw error, vòng lặp sẽ bị ngắt và nhảy xuống catch
        }

        // Chỉ gửi nếu vòng lặp hoàn thành
        if (activeTestRuns.has(scenarioId)) {
             sendTestRunWsMessage(scenarioId, `\n\x1b[1m\x1b[32m*** HOÀN THÀNH CHẠY THỬ ***\x1b[0m`);
        }

    } catch (error) {
        console.error(`[Test Run ${scenarioId}]: Thất bại:`, error.message);
        // Lỗi đã được gửi bởi executeTestRunStep, chỉ cần gửi tín hiệu thất bại
        sendTestRunWsMessage(scenarioId, `\n\x1b[1m\x1b[31m*** CHẠY THỬ THẤT BẠI ***\x1b[0m`);
    } finally {
        console.log(`[Test Run ${scenarioId}]: Kết thúc và dọn dẹp.`);
        activeTestRuns.delete(scenarioId);
        // Gửi tín hiệu đặc biệt báo client là test đã KẾT THÚC (dù thành công hay thất bại)
        // để client có thể re-enable nút "Đóng"
        const clients = testRunClients.get(scenarioId);
        if (clients) {
            clients.forEach(client => {
                if (client.readyState === 1) {
                    client.send(JSON.stringify({ type: 'control', data: 'TEST_RUN_COMPLETE' }));
                }
            });
        }
        // Tự động đóng các kết nối WS sau 5s
        setTimeout(() => {
            const clients = testRunClients.get(scenarioId);
             if (clients) {
                clients.forEach(client => client.close());
                testRunClients.delete(scenarioId);
             }
        }, 5000);
    }
}
// --- END: Helper functions cho Test Run ---

// --- (START) THAY THẾ CỤM LOGIC SERVER ---

// --- Load SSL Certificates ---
// Đảm bảo đặt file .key và .crt vào cùng thư mục với server.js
// (Trong Dockerfile, chúng ta sẽ copy chúng vào thư mục gốc /usr/src/app)
let credentials;
try {
    // Anh/chị cần thay 'certificate.crt' và 'private.key' 
    // bằng tên file public cert thực tế của mình.
    const privateKey = fs.readFileSync('private.key', 'utf8');
    const certificate = fs.readFileSync('certificate.crt', 'utf8');
    credentials = { key: privateKey, cert: certificate };
} catch (err) {
    console.error("LỖI NGHIÊM TRỌNG: Không đọc được file SSL certificate.", err);
    console.error("Hãy đảm bảo file 'private.key' và 'certificate.crt' tồn tại trong cùng thư mục với server.js.");
    // Thoát nếu không có cert, vì yêu cầu là chạy 443
    process.exit(1); 
}

// --- Create HTTPS Server (Port 443) ---
const httpsPort = 443;
const httpsServer = https.createServer(credentials, app);
const wss = new WebSocketServer({ noServer: true }); // WebSocket sẽ gắn vào httpsServer

// --- WebSocket Handling (Gắn vào HTTPS Server) ---
// Giữ nguyên logic upgrade của anh/chị
httpsServer.on('upgrade', (request, socket, head) => {
    const location = url.parse(request.url); // Use url module
    console.log(`[HTTPS Server Upgrade]: Received upgrade request. Path: ${location.pathname}`);
    const pathParts = (location.pathname || '').split('/').filter(p => p);

    if (pathParts[0] === 'ws' && pathParts[1] === 'execution' && pathParts[2]) {
        // Handle /ws/execution/:drillId
        console.log(`[HTTPS Server Upgrade]: Path matches execution. Passing to WSS...`);
        wss.handleUpgrade(request, socket, head, (ws) => {
            wss.emit('connection', ws, request, location); // Pass location
        });
    } else if (pathParts[0] === 'ws' && pathParts[1] === 'servers' && pathParts[2] && pathParts[3] === 'shell') {
        // Handle /ws/servers/:serverId/shell
         console.log(`[HTTPS Server Upgrade]: Path matches shell. Passing to WSS...`);
        wss.handleUpgrade(request, socket, head, (ws) => {
            wss.emit('connection', ws, request, location); // Pass location
        });
    // --- START: Thêm logic upgrade cho Test Run ---
    } else if (pathParts[0] === 'ws' && pathParts[1] === 'scenario_test' && pathParts[2]) {
        // Handle /ws/scenario_test/:scenarioId
        console.log(`[HTTPS Server Upgrade]: Path matches scenario_test. Passing to WSS...`);
        wss.handleUpgrade(request, socket, head, (ws) => {
            wss.emit('connection', ws, request, location);
        });
    // --- END: Thêm logic upgrade cho Test Run ---
    } else {
        // If the path is not recognized, destroy the socket
        console.log(`[HTTPS Server Upgrade]: Path does not match. Destroying socket.`);
        socket.destroy();
    }
});

// --- (GIỮ NGUYÊN TOÀN BỘ LOGIC CỦA wss.on('connection', ...)) ---
// Bỏ: executionClients đã được định nghĩa lại ở trên
// const executionClients = new Map(); // Map drillId -> Set of ws clients
const activeExecutions = new Map(); // Map drillId -> { steps: [], adj: {}, inDegree: {}, currentQueue: [], running: Set<stepId>, failed: boolean } // Thêm cờ failed

// Helper function to find the next steps to run
function findNextSteps(drillId, completedStepId) {
    const execInfo = activeExecutions.get(drillId);
    if (!execInfo) return [];

    const nextSteps = [];
    (execInfo.adj[completedStepId] || []).forEach(vId => {
        const currentInDegree = execInfo.inDegree[vId];
        if (currentInDegree !== undefined) {
             execInfo.inDegree[vId]--;
             if (execInfo.inDegree[vId] === 0) {
                 const nextStep = execInfo.steps.find(s => s.id === vId);
                 if (nextStep) {
                    nextSteps.push(nextStep);
                 }
             }
        } else {
             console.warn(`[Execution ${drillId}]: Step ${vId} not found in inDegree map.`);
        }
    });
    return nextSteps;
}

// Function to execute a single step
// Sửa lỗi: Hàm này cần trả về một promise để báo hiệu thành công/thất bại
async function executeStep(drillId, step) {
     const execInfo = activeExecutions.get(drillId);
     if (!execInfo || execInfo.running.has(step.id)) return Promise.resolve(false); // Trả về promise resolve(false) nếu không thực thi

     execInfo.running.add(step.id);
     console.log(`[Execution ${drillId}]: Starting step ${step.id} (${step.title})`);

     // --- PHASE 1: START STEP ---
     const startTime = new Date();
     let startDbRes;
     try {
         const startPayload = {
             drill_id: drillId, step_id: step.id, status: 'InProgress',
             started_at: startTime.toISOString(), assignee: 'AUTOMATION'
         };
         const startQuery = `
             INSERT INTO execution_steps (drill_id, step_id, status, started_at, assignee, result_text) VALUES ($1, $2, $3, $4, $5, '')
             ON CONFLICT (drill_id, step_id) DO UPDATE SET status = EXCLUDED.status, started_at = EXCLUDED.started_at, assignee = EXCLUDED.assignee, completed_at = NULL, result_text = ''
             RETURNING *;`;
         startDbRes = await pool.query(startQuery, [startPayload.drill_id, startPayload.step_id, startPayload.status, startPayload.started_at, startPayload.assignee]);
         sendWsMessage(drillId, { type: 'STEP_UPDATE', payload: startDbRes.rows[0] });
     } catch(dbError) {
         console.error(`[Execution ${drillId}]: Error updating step ${step.id} to InProgress:`, dbError);
         if (execInfo) execInfo.running.delete(step.id);
         sendWsMessage(drillId, { type: 'EXECUTION_ERROR', payload: { error: `Database error starting step ${step.id}` } });
         if (execInfo) execInfo.failed = true;
         return Promise.reject(new Error(`Database error starting step ${step.id}`)); // Sửa lỗi: Reject promise
     }

     // --- PHASE 2: EXECUTE COMMAND using node-pty ---
     const { command, server_user, ip_address } = step;
     let accumulatedLog = '';

     if (!command || !server_user || !ip_address) {
         accumulatedLog = "Lỗi cấu hình: Thiếu lệnh, user hoặc IP server.";
         const payload = { drill_id: drillId, step_id: step.id, status: 'Completed-Failure', completed_at: new Date().toISOString(), result_text: accumulatedLog };
         try {
            const dbRes = await pool.query(`UPDATE execution_steps SET status = $1, completed_at = $2, result_text = $3 WHERE drill_id = $4 AND step_id = $5 RETURNING *;`, [payload.status, payload.completed_at, payload.result_text, payload.drill_id, payload.step_id]);
            sendWsMessage(drillId, { type: 'STEP_UPDATE', payload: dbRes.rows[0] });
         } catch (dbError) {
             console.error(`[Execution ${drillId}]: DB Error updating failed config step ${step.id}:`, dbError);
         }
         if (execInfo) execInfo.running.delete(step.id);
         sendWsMessage(drillId, { type: 'EXECUTION_PAUSED_ON_FAILURE', payload: { step_id: step.id, error: accumulatedLog } });
         if (execInfo) execInfo.failed = true;
         return Promise.reject(new Error(accumulatedLog)); // Sửa lỗi: Reject promise
     }

     return new Promise((resolve, reject) => { // Sửa lỗi: Thêm reject
         let ptyError = null; // Store potential error
         let exitHandled = false; // Flag to prevent double handling
         let errorTimeout = null; // Timeout handle

         const ptyProcess = pty.spawn('ssh', [`${server_user}@${ip_address}`, '-o', 'StrictHostKeyChecking=no', '-o', 'ConnectTimeout=10', command], {
             name: 'xterm-color', cols: 80, rows: 30, cwd: process.env.HOME, env: process.env
         });

         ptyProcess.onData(data => {
             accumulatedLog += data;
             sendWsMessage(drillId, { type: 'STEP_LOG_UPDATE', payload: { step_id: step.id, log_chunk: data } });
         });

         ptyProcess.onExit(async ({ exitCode, signal }) => {
             if (exitHandled) return;
             exitHandled = true;
             clearTimeout(errorTimeout); // Clear safety timeout

             const currentExecInfo = activeExecutions.get(drillId);
             if (!currentExecInfo) {
                console.log(`[Execution ${drillId}]: Execution context removed before step ${step.id} exit handler.`);
                return reject(new Error(`Execution context removed for step ${step.id}`));
             }

             console.log(`[Execution ${drillId}]: Step ${step.id} exited with code ${exitCode}, signal ${signal}`);
             // SỬA LỖI: Ưu tiên exitCode 0 ngay cả khi có lỗi EIO trước đó
             const success = exitCode === 0;
             const status = success ? 'Completed-Success' : 'Completed-Failure';
             const completed_at = new Date().toISOString();
             // Append error message only if failed based on exit code
             if (!success && !accumulatedLog.includes('Execution failed')) {
                accumulatedLog += `\nExecution failed with exit code ${exitCode}.`;
             }
             // Include the captured ptyError in the log if exit was non-zero
             if (!success && ptyError && !accumulatedLog.includes(ptyError.message)) {
                 accumulatedLog += `\nPty Error: ${ptyError.message} (Code: ${ptyError.code})`;
             }

             const endPayload = { drill_id: drillId, step_id: step.id, status, completed_at, result_text: accumulatedLog };

             try {
                 const endQuery = `UPDATE execution_steps SET status = $1, completed_at = $2, result_text = $3 WHERE drill_id = $4 AND step_id = $5 RETURNING *;`;
                 const endDbRes = await pool.query(endQuery, [endPayload.status, endPayload.completed_at, endPayload.result_text, endPayload.drill_id, endPayload.step_id]);
                 sendWsMessage(drillId, { type: 'STEP_UPDATE', payload: endDbRes.rows[0] });
             } catch (dbError) {
                 console.error(`[Execution ${drillId}]: DB Error updating completed step ${step.id}:`, dbError);
             }

             currentExecInfo.running.delete(step.id);

             if (success) {
                 const nextSteps = findNextSteps(drillId, step.id);
                 if (nextSteps.length > 0) {
                     currentExecInfo.currentQueue.push(...nextSteps);
                 }
                 resolve(true); // Resolve thành công
             } else {
                 const errorMessage = `Execution failed with exit code ${exitCode}. Check logs. ${ptyError ? `(Pty Error: ${ptyError.message})`: ''}`;
                 sendWsMessage(drillId, { type: 'EXECUTION_PAUSED_ON_FAILURE', payload: { step_id: step.id, error: errorMessage, exitCode: exitCode, ptyErrorCode: ptyError?.code } });
                 currentExecInfo.failed = true;
                 reject(new Error(errorMessage)); // Reject promise khi thất bại
             }
         });

         ptyProcess.on('error', async (err) => {
             const currentExecInfo = activeExecutions.get(drillId);
             // SỬA LỖI: Chỉ ghi log và lưu lỗi EIO, không reject ngay
             console.error(`[Execution ${drillId}]: Pty process error for step ${step.id} (Command: '${command}'):`, err);
             ptyError = err; // Store the error

             // Nếu lỗi không phải EIO HOẶC đã có xử lý exit rồi thì bỏ qua
             if (err.code !== 'EIO' || exitHandled) {
                 if (exitHandled) return; // Exit đã xử lý rồi
                  exitHandled = true; // Đánh dấu đã xử lý lỗi nghiêm trọng này
                  clearTimeout(errorTimeout); // Hủy timeout

                 accumulatedLog += `\nCritical Internal Execution Error: ${err.message} (Code: ${err.code}, Syscall: ${err.syscall})`;
                 const status = 'Completed-Failure';
                 const completed_at = new Date().toISOString();
                 const endPayload = { drill_id: drillId, step_id: step.id, status, completed_at, result_text: accumulatedLog };
                 try {
                     const endQuery = `UPDATE execution_steps SET status = $1, completed_at = $2, result_text = $3 WHERE drill_id = $4 AND step_id = $5 RETURNING *;`;
                     const endDbRes = await pool.query(endQuery, [endPayload.status, endPayload.completed_at, endPayload.result_text, endPayload.drill_id, endPayload.step_id]);
                     sendWsMessage(drillId, { type: 'STEP_UPDATE', payload: endDbRes.rows[0] });
                 } catch (dbError) {
                     console.error(`[Execution ${drillId}]: DB Error updating failed pty step ${step.id}:`, dbError);
                 }
                  if (currentExecInfo) {
                     currentExecInfo.running.delete(step.id);
                     currentExecInfo.failed = true;
                 }
                 const detailedError = `Critical internal execution error: ${err.message} (Code: ${err.code})`;
                 sendWsMessage(drillId, { type: 'EXECUTION_PAUSED_ON_FAILURE', payload: { step_id: step.id, error: detailedError, code: err.code } });
                 reject(new Error(detailedError)); // Reject promise
             } else {
                  // Nếu là lỗi EIO, chỉ lưu lại, đợi onExit hoặc timeout
                  console.warn(`[Execution ${drillId}]: Captured EIO error for step ${step.id}. Waiting for exit code or timeout.`);
             }
        });

         // SỬA LỖI: Timeout an toàn
         errorTimeout = setTimeout(() => {
             if (exitHandled) return; // Đã exit bình thường
             exitHandled = true; // Đánh dấu đã xử lý do timeout
             const currentExecInfo = activeExecutions.get(drillId);
             const errorMessage = ptyError ? `Step ${step.id} timed out after error: ${ptyError.message}` : `Step ${step.id} timed out without exiting.`;
             console.warn(`[Execution ${drillId}]: ${errorMessage}`);

             accumulatedLog += `\nError: ${errorMessage}`;
             const status = 'Completed-Failure';
             const completed_at = new Date().toISOString();
             const endPayload = { drill_id: drillId, step_id: step.id, status, completed_at, result_text: accumulatedLog };

             // Cố gắng cập nhật DB lần cuối
             pool.query(`UPDATE execution_steps SET status = $1, completed_at = $2, result_text = $3 WHERE drill_id = $4 AND step_id = $5 RETURNING *;`,
                 [endPayload.status, endPayload.completed_at, endPayload.result_text, endPayload.drill_id, endPayload.step_id]
             ).then(endDbRes => {
                 sendWsMessage(drillId, { type: 'STEP_UPDATE', payload: endDbRes.rows[0] });
             }).catch(dbError => {
                 console.error(`[Execution ${drillId}]: DB Error updating timed out step ${step.id}:`, dbError);
             }).finally(() => {
                 if (currentExecInfo) {
                     currentExecInfo.running.delete(step.id);
                     currentExecInfo.failed = true;
                 }
                 sendWsMessage(drillId, { type: 'EXECUTION_PAUSED_ON_FAILURE', payload: { step_id: step.id, error: errorMessage, timedOut: true } });
                 reject(new Error(errorMessage)); // Reject promise do timeout
             });
         }, 300000); // Đặt timeout hơi dài hơn timeout của SSH một chút (ví dụ 65s)
     });
}

// Function to process the execution queue for a drill
async function processExecutionQueue(drillId) {
    const execInfo = activeExecutions.get(drillId);
    if (!execInfo) {
        console.log(`[Execution ${drillId}]: Execution stopped or context removed.`);
        return;
    }
    if (execInfo.failed) {
        console.log(`[Execution ${drillId}]: Execution paused due to previous error. Halting queue processing.`);
        return;
    }

    if (execInfo.currentQueue.length === 0) {
        if(execInfo.running.size === 0 && !execInfo.failed) {
            console.log(`[Execution ${drillId}]: Queue empty and no steps running. Execution complete.`);
            sendWsMessage(drillId, { type: 'EXECUTION_COMPLETE', payload: {} });
            activeExecutions.delete(drillId);
        } else if (execInfo.running.size > 0) {
             console.log(`[Execution ${drillId}]: Queue empty but ${execInfo.running.size} steps still running.`);
        }
        return;
    }

    const stepsToRun = [...execInfo.currentQueue];
    execInfo.currentQueue = [];

    sendWsMessage(drillId, { type: 'LEVEL_START', payload: { step_ids: stepsToRun.map(s => s.id) } });

    // Sửa lỗi: Xử lý lỗi từ Promise.all
    try {
        // Execute steps in parallel and wait for results
        await Promise.all(stepsToRun.map(step => executeStep(drillId, step)));

        // Sửa lỗi: Chỉ tiếp tục nếu không có lỗi nào xảy ra và context còn tồn tại
        const currentExecInfo = activeExecutions.get(drillId); // Lấy lại thông tin mới nhất
        if (currentExecInfo && !currentExecInfo.failed) {
            // Nếu queue vẫn còn trống và không có gì đang chạy
            if (currentExecInfo.currentQueue.length === 0 && currentExecInfo.running.size === 0) {
                processExecutionQueue(drillId); // Gọi lại để kiểm tra và gửi EXECUTION_COMPLETE
            } else if (currentExecInfo.currentQueue.length > 0) {
                processExecutionQueue(drillId); // Xử lý các bước được thêm vào queue
            }
        } else if (currentExecInfo && currentExecInfo.failed) {
            console.log(`[Execution ${drillId}]: Execution paused after processing level due to failure.`);
            // Không làm gì thêm, đợi Retry hoặc Skip
        } else {
             console.log(`[Execution ${drillId}]: Execution stopped externally after processing level.`);
        }
    } catch (error) {
        // Lỗi này xảy ra nếu một trong các executeStep bị reject
        console.error(`[Execution ${drillId}]: Error processing execution level:`, error.message || error);
        // Không cần làm gì thêm ở đây vì executeStep đã xử lý việc gửi PAUSED_ON_FAILURE
        const currentExecInfo = activeExecutions.get(drillId);
        if (currentExecInfo) {
             currentExecInfo.failed = true; // Đảm bảo cờ lỗi được đặt
             console.log(`[Execution ${drillId}]: Marked execution as failed.`);
        }
    }
}


// Shared function to start or restart execution flow
async function startOrResumeExecution(drillId, stepsToRunIds) {
    try {
        const existingExec = activeExecutions.get(drillId);
        if (existingExec && !existingExec.failed) {
             console.warn(`[Execution ${drillId}]: Attempted to start execution while already active and not failed. Ignoring.`);
             return;
        }


         // --- Fetch Scenario Data ---
        if (!stepsToRunIds || stepsToRunIds.length === 0) {
            throw new Error("Cannot start execution with an empty step list.");
        }
        const scenarioIdRes = await pool.query('SELECT scenario_id FROM steps WHERE id = $1', [stepsToRunIds[0]]);
        if (scenarioIdRes.rows.length === 0) throw new Error(`Scenario not found for step ${stepsToRunIds[0]}`);
        const scenarioId = scenarioIdRes.rows[0].scenario_id;

        const stepsRes = await pool.query(`SELECT s.*, ms.ip_address FROM steps s LEFT JOIN managed_servers ms ON s.server_id = ms.id WHERE s.scenario_id = $1 ORDER BY s.step_order`, [scenarioId]);
        const allStepsInScenario = stepsRes.rows;
        const allStepIds = allStepsInScenario.map(s => s.id);
        const depsRes = await pool.query('SELECT * FROM step_dependencies WHERE step_id = ANY($1::text[]) OR depends_on_step_id = ANY($1::text[])', [allStepIds]);
        const dependencies = depsRes.rows;

        // --- Build Dependency Graph for the *entire* scenario ---
        const adj = {};
        const originalInDegree = {};
        allStepsInScenario.forEach(s => {
            adj[s.id] = [];
            originalInDegree[s.id] = 0;
        });
        dependencies.forEach(dep => {
            if(adj[dep.depends_on_step_id] && allStepIds.includes(dep.step_id)) {
                adj[dep.depends_on_step_id].push(dep.step_id);
                originalInDegree[dep.step_id]++;
            }
        });

         // --- Determine Starting Queue based on stepsToRunIds ---
        let initialQueue = [];
        // Clone original degrees for this specific run's calculation
        const currentInDegreeForRun = { ...originalInDegree };

        // Determine which steps outside stepsToRunIds can be considered "already met"
        const alreadyMetDependencies = new Set();
        const executionStepsStatusRes = await pool.query('SELECT step_id, status from execution_steps where drill_id = $1 AND step_id = ANY($2::text[])', [drillId, allStepIds]);
        const currentStepStatuses = executionStepsStatusRes.rows.reduce((acc, row) => {
             acc[row.step_id] = row.status;
             return acc;
        }, {});


        // Adjust in-degrees based on already met dependencies outside the run list
        allStepsInScenario.forEach(s => {
            if (stepsToRunIds.includes(s.id)) { // Chỉ quan tâm các bước cần chạy
                dependencies.forEach(dep => {
                    if (dep.step_id === s.id && !stepsToRunIds.includes(dep.depends_on_step_id)) {
                         // Check status from DB ONLY if dependency is outside run list
                         if (currentStepStatuses[dep.depends_on_step_id] === 'Completed-Success') {
                            if(currentInDegreeForRun[s.id] > 0) currentInDegreeForRun[s.id]--; // Decrement only if > 0
                         }
                    }
                });
            }
        });

         // Find steps within stepsToRunIds that now have an in-degree of 0
         initialQueue = allStepsInScenario.filter(s =>
             stepsToRunIds.includes(s.id) && currentInDegreeForRun[s.id] <= 0
         );

        // --- Store or Update Execution Info ---
         // If resuming/retrying, update existing context, else create new
         if (existingExec) {
             console.log(`[Execution ${drillId}]: Resuming/Retrying. Updating context.`);
             existingExec.currentQueue = initialQueue;
             existingExec.failed = false; // Reset failed flag
             // Keep existing adj and steps, but reset inDegree for the new run
             existingExec.inDegree = { ...originalInDegree };
             // Reset degrees based on already met steps outside the CURRENT run again
             allStepsInScenario.forEach(s => {
                if(activeExecutions.get(drillId)?.inDegree[s.id] > 0) { // Check if degree needs adjustment
                     dependencies.forEach(dep => {
                        if (dep.step_id === s.id && !stepsToRunIds.includes(dep.depends_on_step_id) && currentStepStatuses[dep.depends_on_step_id] === 'Completed-Success') {
                            activeExecutions.get(drillId).inDegree[s.id]--;
                        }
                    });
                }
             });
         } else {
             activeExecutions.set(drillId, {
                 steps: allStepsInScenario,
                 adj: adj,
                 inDegree: { ...originalInDegree }, // Use a fresh clone for tracking this run
                 currentQueue: initialQueue,
                 running: new Set(),
                 failed: false // Initialize failed flag
             });
         }


        console.log(`[Execution ${drillId}]: Starting/Resuming. Initial queue:`, initialQueue.map(s => s.id));
        processExecutionQueue(drillId); // Start processing

    } catch (err) {
         console.error(`[Execution ${drillId}]: Error preparing execution:`, err);
         sendWsMessage(drillId, { type: 'EXECUTION_ERROR', payload: { error: `Failed to prepare execution: ${err.message}` } });
         activeExecutions.delete(drillId); // Clean up if preparation fails
    }
}


// API to start automatic execution
app.post('/api/execution/scenario/:id/start_automatic', async (req, res) => {
    const { id: scenarioId } = req.params;
    const { drill_id: drillId } = req.body;

     if (activeExecutions.has(drillId)) {
        const execInfo = activeExecutions.get(drillId);
        if (!execInfo.failed) {
             return res.status(409).json({ message: 'Execution already in progress for this drill.' });
        }
        console.log(`[Execution ${drillId}]: Previous run failed. Resetting and starting fresh.`);
        activeExecutions.delete(drillId);
     }


    try {
        // Reset all steps in this scenario for this drill to Pending before starting
        const stepsToReset = await pool.query('SELECT id FROM steps WHERE scenario_id = $1', [scenarioId]);
        const stepIdsToReset = stepsToReset.rows.map(r => r.id);

        if (stepIdsToReset.length > 0) {
            await pool.query(
                "UPDATE execution_steps SET status = 'Pending', started_at = NULL, completed_at = NULL, result_text = NULL WHERE drill_id = $1 AND step_id = ANY($2::text[])",
                [drillId, stepIdsToReset]
            );
             // Send reset updates
            for (const stepId of stepIdsToReset) {
                 sendWsMessage(drillId, { type: 'STEP_UPDATE', payload: { drill_id: drillId, step_id: stepId, status: 'Pending', result_text: null } });
            }
        }

        res.status(202).json({ message: 'Execution started' });
        // Start execution asynchronously for all steps in the scenario
        startOrResumeExecution(drillId, stepIdsToReset);

    } catch (err) {
        console.error(`Error starting automatic execution for scenario ${scenarioId}:`, err);
        if (!res.headersSent) {
            res.status(500).json({ error: 'Internal server error' });
        }
         activeExecutions.delete(drillId); // Clean up if start fails
    }
});

// API to rerun specific steps
app.post('/api/execution/scenario/:id/rerun', async (req, res) => {
    const { id: scenarioId } = req.params; // scenarioId is correct here
    const { drill_id: drillId, steps_to_run: stepsToRun } = req.body;

    if (!stepsToRun || stepsToRun.length === 0) {
        return res.status(400).json({ error: 'No steps provided to rerun.' });
    }
     if (activeExecutions.has(drillId)) {
        const execInfo = activeExecutions.get(drillId);
        if (!execInfo.failed) {
             return res.status(409).json({ message: 'Execution already in progress for this drill. Cannot rerun yet.' });
        }
         console.log(`[Execution ${drillId}]: Previous run failed. Allowing rerun.`);
         // Don't delete activeExecutions, startOrResumeExecution will handle update/reset
     }


    try {
         // Reset only the specified steps
         await pool.query(
             "UPDATE execution_steps SET status = 'Pending', started_at = NULL, completed_at = NULL, result_text = NULL WHERE drill_id = $1 AND step_id = ANY($2::text[])",
             [drillId, stepsToRun]
         );
         // Send reset updates
         for (const stepId of stepsToRun) {
              sendWsMessage(drillId, { type: 'STEP_UPDATE', payload: { drill_id: drillId, step_id: stepId, status: 'Pending', result_text: null } });
         }

        res.status(202).json({ message: 'Rerun execution started' });
        // Start execution asynchronously only for the selected steps
        startOrResumeExecution(drillId, stepsToRun);

    } catch (err) {
        console.error(`Error starting rerun for scenario ${scenarioId}:`, err);
        if (!res.headersSent) {
            res.status(500).json({ error: 'Internal server error' });
        }
         // Clean up only if startOrResumeExecution hasn't stored the context yet
         if (!activeExecutions.has(drillId)) {
             activeExecutions.delete(drillId);
         }
    }
});

wss.on('connection', async (ws, req, location) => { // Receive location here
    const pathParts = (location.pathname || '').split('/').filter(p => p);

    if (pathParts[0] === 'ws' && pathParts[1] === 'execution' && pathParts[2]) {
        const drillId = pathParts[2];
        console.log(`Execution WebSocket client connected for drill: ${drillId}`);
        if (!executionClients.has(drillId)) {
            executionClients.set(drillId, new Set());
        }
        executionClients.get(drillId).add(ws);

        ws.on('message', async (message) => { // Make handler async
            console.log(`Received execution message from ${drillId}: ${message}`);
            try {
                const parsedMessage = JSON.parse(message);
                const stepId = parsedMessage.payload?.step_id;

                 if (parsedMessage.type === 'RETRY_STEP' && stepId) {
                     console.log(`[Execution ${drillId}]: RETRY requested for step: ${stepId}`);
                     // Sửa lỗi: Chỉ cho phép retry nếu execution đang ở trạng thái paused (failed=true)
                     const execInfo = activeExecutions.get(drillId);
                     if (!execInfo || !execInfo.failed) {
                          console.warn(`[Execution ${drillId}]: Cannot retry step ${stepId}. No failed execution found or execution still running.`);
                          return;
                     }
                      await pool.query("UPDATE execution_steps SET status = 'Pending', started_at = NULL, completed_at = NULL, result_text = NULL WHERE drill_id = $1 AND step_id = $2", [drillId, stepId]);
                     sendWsMessage(drillId, { type: 'STEP_UPDATE', payload: { drill_id: drillId, step_id: stepId, status: 'Pending', result_text: null } });
                     startOrResumeExecution(drillId, [stepId]); // Gọi hàm resume

                } else if (parsedMessage.type === 'SKIP_STEP' && stepId) {
                     console.log(`[Execution ${drillId}]: SKIP requested for step: ${stepId}`);
                     const execInfo = activeExecutions.get(drillId);
                      // Sửa lỗi: Chỉ cho phép skip nếu execution đang ở trạng thái paused (failed=true)
                     if (execInfo && execInfo.failed) {
                        // Mark step as skipped in DB and notify client
                        const skipPayload = { drill_id: drillId, step_id: stepId, status: 'Completed-Skipped', completed_at: new Date().toISOString(), result_text: 'Skipped by user.'};
                        try {
                           const skipRes = await pool.query('UPDATE execution_steps SET status=$1, completed_at=$2, result_text=$3 WHERE drill_id=$4 AND step_id=$5 RETURNING *', [skipPayload.status, skipPayload.completed_at, skipPayload.result_text, skipPayload.drill_id, skipPayload.step_id]);
                           sendWsMessage(drillId, { type: 'STEP_UPDATE', payload: skipRes.rows[0] });
                        } catch(dbErr) {
                           console.error(`[Execution ${drillId}]: Error marking step ${stepId} as skipped:`, dbErr);
                           // Continue anyway, try to run next steps
                        }

                         execInfo.running.delete(stepId); // Remove from running set if it was there
                         execInfo.failed = false; // Reset failed flag as we are skipping the failure

                         // Find and trigger next steps based on the original graph info
                         const nextSteps = findNextSteps(drillId, stepId); // Use the helper
                         if (nextSteps.length > 0) {
                              // Sửa lỗi: Chỉ thêm bước vào queue nếu nó chưa tồn tại
                             nextSteps.forEach(nextStep => {
                                 if (!execInfo.currentQueue.some(s => s.id === nextStep.id)) {
                                     execInfo.currentQueue.push(nextStep);
                                 }
                             });
                             console.log(`[Execution ${drillId}]: Added next steps after skip:`, nextSteps.map(s=>s.id));
                             processExecutionQueue(drillId); // Trigger next level/check completion
                         } else {
                            // Check if execution should complete after skipping
                            console.log(`[Execution ${drillId}]: No next steps found after skipping ${stepId}. Checking completion...`);
                            processExecutionQueue(drillId); // Gọi để kiểm tra hoàn thành
                         }
                     } else {
                         console.warn(`[Execution ${drillId}]: Cannot skip step ${stepId}, no active execution found or not in failed state.`);
                         // Optionally, just mark as skipped if no execution is active but DB entry exists?
                         // This case might indicate an inconsistent state.
                         const skipPayload = { drill_id: drillId, step_id: stepId, status: 'Completed-Skipped', completed_at: new Date().toISOString(), result_text: 'Skipped by user (no active exec).'}
                         try {
                           const skipRes = await pool.query('UPDATE execution_steps SET status=$1, completed_at=$2, result_text=$3 WHERE drill_id=$4 AND step_id=$5 RETURNING *', [skipPayload.status, skipPayload.completed_at, skipPayload.result_text, skipPayload.drill_id, skipPayload.step_id]);
                           sendWsMessage(drillId, { type: 'STEP_UPDATE', payload: skipRes.rows[0] });
                         } catch(dbErr) { console.error(`[Execution ${drillId}]: Error marking step ${stepId} as skipped (no active exec):`, dbErr); }
                     }
                }
            } catch (e) {
                console.error(`[Execution ${drillId}]: Error parsing message or unknown message type:`, e);
            }
        });

        ws.on('close', () => {
            console.log(`Execution WebSocket client disconnected for drill: ${drillId}`);
            const clients = executionClients.get(drillId);
            if (clients) {
                clients.delete(ws);
                if (clients.size === 0) {
                    executionClients.delete(drillId);
                }
            }
        });
        ws.on('error', (error) => {
             console.error(`Execution WebSocket error for drill ${drillId}:`, error);
        });

    // --- START: Thêm logic connection cho Test Run ---
    } else if (pathParts[0] === 'ws' && pathParts[1] === 'scenario_test' && pathParts[2]) {
        const scenarioId = pathParts[2];
        console.log(`Test Run WebSocket client connected for scenario: ${scenarioId}`);
        if (!testRunClients.has(scenarioId)) {
            testRunClients.set(scenarioId, new Set());
        }
        testRunClients.get(scenarioId).add(ws);

        if (activeTestRuns.has(scenarioId)) {
            ws.send(JSON.stringify({ type: 'log', data: '\x1b[33m*** Đã tham gia vào phiên chạy thử đang diễn ra... ***\x1b[0m' }));
        } else {
            ws.send(JSON.stringify({ type: 'log', data: '\x1b[33m*** Đã kết nối. Sẵn sàng nhận lệnh chạy thử từ API. ***\x1b[0m' }));
        }

        ws.on('message', (message) => {
            // Hiện tại không xử lý message từ client cho Test Run (ví dụ: input)
            console.log(`[Test Run ${scenarioId}]: Received message (ignored): ${message}`);
        });

        ws.on('close', () => {
            console.log(`Test Run WebSocket client disconnected for scenario: ${scenarioId}`);
            const clients = testRunClients.get(scenarioId);
            if (clients) {
                clients.delete(ws);
                if (clients.size === 0) {
                    testRunClients.delete(scenarioId);
                }
            }
        });
        ws.on('error', (error) => {
             console.error(`Test Run WebSocket error for scenario ${scenarioId}:`, error);
        });
    // --- END: Thêm logic connection cho Test Run ---

    } else if (pathParts[0] === 'ws' && pathParts[1] === 'servers' && pathParts[2] && pathParts[3] === 'shell') {
        const serverId = pathParts[2];
        console.log(`Shell WebSocket client connected for server: ${serverId}`);
        try {
            const serverRes = await pool.query('SELECT ip_address, ssh_user FROM managed_servers WHERE id = $1', [serverId]);
            if (serverRes.rows.length === 0) {
                ws.send('\r\n\x1b[31mError: Server không tồn tại trong database.\x1b[0m');
                ws.close();
                return;
            }
            const { ip_address, ssh_user } = serverRes.rows[0];
            const ptyProcess = pty.spawn('ssh', [`${ssh_user}@${ip_address}`, '-o', 'StrictHostKeyChecking=no', '-o', 'KexAlgorithms=+diffie-hellman-group1-sha1'], { name: 'xterm-256color', cols: 80, rows: 30, cwd: process.env.HOME, env: process.env });

            ptyProcess.onData(data => {
                if (ws.readyState === 1) { ws.send(data); }
            });

            ws.on('message', (message) => {
                try {
                    const msg = JSON.parse(message);
                    if (msg.type === 'input') { ptyProcess.write(msg.data); }
                    else if (msg.type === 'resize' && msg.cols && msg.rows) { ptyProcess.resize(msg.cols, msg.rows); }
                } catch (e) {
                    ptyProcess.write(message.toString());
                }
            });

            ptyProcess.onExit(({ exitCode }) => {
                if (ws.readyState === 1) { ws.close(); }
            });

            ws.on('close', () => {
                ptyProcess.kill();
                console.log(`Shell for server ${serverId} closed.`);
            });
             ws.on('error', (error) => {
                console.error(`Shell WebSocket error for server ${serverId}:`, error);
                ptyProcess.kill(); // Ensure pty is killed on ws error
            });

        } catch (err) {
            console.error(`Error setting up shell for server ${serverId}:`, err);
            if (ws.readyState === 1) {
                ws.send(`\r\n\x1b[31mError: Không thể khởi tạo remote shell. Vui lòng kiểm tra log của server.\x1b[0m`);
                ws.close();
            }
        }
    } else {
        console.log(`[WSS Connection]: Invalid path post-handshake. Closing connection. URL: ${location.pathname || '(unknown)'}`);
        ws.close();
    }
});
// --- (HẾT PHẦN LOGIC CỦA wss.on('connection')) ---


// Khởi động HTTPS server
httpsServer.listen(httpsPort, () => {
  console.log(`Máy chủ HTTPS (Frontend + API) đang chạy trên https://localhost:${httpsPort}`);
});

// --- Create HTTP Redirect Server (Port 80) ---
// Máy chủ này chỉ để chuyển hướng HTTP sang HTTPS
const httpPort = 80;
const httpRedirectApp = express();
httpRedirectApp.use((req, res) => {
    // Chuyển hướng sang https, giữ nguyên host và path
    res.redirect(301, `https://${req.headers.host}${req.url}`);
});

const httpServer = http.createServer(httpRedirectApp);
httpServer.listen(httpPort, () => {
    console.log(`Máy chủ HTTP đang chạy trên port ${httpPort} để chuyển hướng sang HTTPS.`);
});

